{"version":3,"sources":["utils.js","game/game.reducer.js","game/components/Cell.jsx","game/game.utils.js","game/components/GameField.jsx","game/components/Styled.js","game/index.jsx","App.jsx","serviceWorker.js","index.js"],"names":["getFromTheme","themePath","props","path","split","theme","initialState","level","showHidden","showField","levelConfig","levels","GameReducer","state","action","type","merge","CellView","styled","div","size","space","ActiveCellView","width","FailedCellView","Cell","memo","id","value","isActive","forceShowHidden","isFailed","FieldView","animationState","Field","fieldSize","cellCount","field","hiddenCells","dispatch","updateLevel","visible","cellSize","useState","gameField","setField","gameHiddenCells","setHidden","onCellClick","target","Number","includes","updatedField","map","e","i","updatedHidden","filter","length","setTimeout","useGameField","useEffect","onClick","cellValue","key","GameView","GameFieldView","SwitchView","toggleTheme","useReducer","memoryCount","useMemo","cellsIndexes","Array","_","fill","rNum","Math","floor","random","toChange","splice","pop","push","generateGameField","shouldReset","App","defaultThemeName","themeName","setTheme","name","useTheme","GlobalStyle","createGlobalStyle","themes","Fragment","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"+pBAGO,SAASA,IAA+B,IAAjBC,EAAgB,uDAAJ,GACtC,OAAO,WAAyC,IAAbC,EAAY,uDAAJ,GACvC,OAAOC,YAAKF,EAAUG,MAAM,KAAMF,EAAMG,Q,2BCQnCC,EAAe,CACxBC,MAHgB,EAIhBC,YAAY,EACZC,WAAW,EACXC,YAAaC,EANG,IASb,SAASC,EAAYC,EAAOC,GAC/B,OAAOA,EAAOC,MACV,IAlBiB,YAmBb,OAAOC,YAAMH,EAAO,CAAEN,MAAOO,EAAOP,MAAOG,YAAaC,EAAOG,EAAOP,SAC1E,IAlBwB,cAmBpB,OAAOS,YAAMH,EAAO,CAAEL,YAAY,IACtC,IArBwB,cAsBpB,OAAOQ,YAAMH,EAAO,CAAEL,YAAY,IACtC,IArBkB,aAsBd,OAAOQ,YAAMH,EAAO,CAAEJ,WAAW,IACrC,IAtBkB,aAuBd,OAAOO,YAAMH,EAAO,CAAEJ,WAAW,IACrC,IAvBmB,cAwBf,OAAOO,YAAMV,EAAc,CAAEI,YAAY,eAAMC,EAtBvC,MAuBZ,QACI,OAAOE,G,skBC7BnB,IAAMI,EAAWC,IAAOC,IAAV,KACD,qBAAGC,QACF,qBAAGA,OACCpB,EAAa,YACjB,qBAAGqB,SAMXC,EAAiBJ,IAAOC,IAAV,KACP,qBAAGI,QAEEvB,EAAa,kBAIzBwB,EAAiBN,IAAOC,IAAV,KACP,qBAAGC,QACF,qBAAGA,OACCpB,EAAa,kBAIlByB,EAAOC,gBAAK,SAAcxB,GAAQ,IACnCyB,EAA+BzB,EAA/ByB,GAAIC,EAA2B1B,EAA3B0B,MAENC,EAFiC3B,EAApB4B,iBCTI,IDWcF,GCbL,IDa+BA,EACzDG,GAAYH,EAElB,OACI,kBAACX,EAAaf,EACV,kBAACoB,EAAD,CAAgBK,GAAIA,EAAIJ,MAAOM,EAAW,IAAM,IAChD,kBAACL,EAAD,CAAgBG,GAAIA,EAAIP,KAAMW,EAAW,IAAM,Q,sTE/B3D,IAAMC,EAAYd,IAAOC,IAAV,KAOA,qBAAGc,kBACK,qBAAGA,kBAIbC,EAAQR,gBAAK,YAWtB,IAAD,IAVCS,iBAUD,MAVa,EAUb,MATCC,iBASD,MATa,EASb,MARCf,aAQD,MARS,EAQT,MAPCgB,aAOD,MAPS,GAOT,MANCC,mBAMD,MANe,GAMf,MALC/B,aAKD,MALS,EAKT,MAJCC,kBAID,SAHC+B,EAGD,EAHCA,SACAC,EAED,EAFCA,YACAC,EACD,EADCA,QAEMC,EAAWP,EAAYC,EAAYf,EAD1C,EAgCH,SAAsBgB,EAAOC,EAAaE,GAAc,IAAD,EACrBG,mBAASN,GADY,mBAC5CO,EAD4C,KACjCC,EADiC,OAEdF,mBAASL,GAFK,mBAE5CQ,EAF4C,KAE3BC,EAF2B,KAuBnD,MAAO,CAAEH,YAAWI,YAnBpB,YAAkC,IAAXC,EAAU,EAAVA,OACbtB,EAAKuB,OAAOD,EAAOtB,IAEzB,GAAIW,EAAYa,SAASxB,GAAK,CAC1B,IAAMyB,EAAeR,EAAUS,KAAI,SAACC,EAAGC,GAAJ,OAAUA,IAAM5B,EDnD3B,ECmDuD2B,KACzEE,EAAgBV,EAAgBW,QAAO,SAAAH,GAAC,OAAIA,IAAM3B,KAKxD,OAHAkB,EAASO,GACTL,EAAUS,IAEFA,EAAcE,QAAUC,WAAWnB,EAAa,KAG5D,IAAMY,EAAeR,EAAUS,KAAI,SAACC,EAAGC,GAAJ,OAAUA,IAAM5B,ED7DzB,EC6DmD2B,KAG7E,OAFAT,EAASO,GAEFO,WAAWnB,EAAa,KAAM,KAjDNoB,CAAavB,EAAOC,EAAaE,GAA5DI,EAHT,EAGSA,UAAWI,EAHpB,EAGoBA,YAUnB,OARAa,qBACI,WACItB,EAAS,CAAExB,KHhCS,gBGiCpB4C,YAAW,kBAAMpB,EAAS,CAAExB,KHlCR,kBGkCmC,QAE3D,CAACR,IAID,kBAACyB,EAAD,CACIC,eAAgBQ,EAAU,EAAI,EAC9BqB,QAAUtD,EAA2B,KAAdwC,GAEnBJ,EAAUS,KAAI,SAACU,EAAWR,GAAZ,OACV,kBAAC,EAAD,CACInC,KAAMsB,EACNrB,MAAOA,EACP2C,IAAKT,EACL5B,GAAI4B,EACJ3B,MAAOmC,EACPjC,gBAAiBtB,W,keCtDlC,IAAMyD,EAAW/C,IAAOC,IAAV,KASR+C,EAAgBhD,IAAOC,IAAV,KACb,qBAAGgB,UAAH,EAAcC,UAAd,EAAyBf,SACxB,qBAAGc,UAAH,EAAcC,UAAd,EAAyBf,SAI1B8C,EAAajD,IAAOC,IAAV,K,uBC4CRO,sBAhDf,YAAiC,IAAhB0C,EAAe,EAAfA,YAAe,EACsCC,qBAC9DzD,EAAaN,GAFW,0BACnBC,EADmB,EACnBA,MAAOC,EADY,EACZA,WAAYC,EADA,EACAA,UAAWC,EADX,EACWA,YAAe6B,EAD1B,KAKpBH,EAA2B1B,EAA3B0B,UAAWkC,EAAgB5D,EAAhB4D,YALS,EAOGC,mBAC3B,kBHrBD,SAA2BnC,EAAWkC,GAMzC,IALA,IAAME,EAAe,YAAIC,MAAMrC,EAAYA,IACtCiB,KAAI,SAACqB,EAAGnB,GAAJ,OAAUA,KACblB,EAAQ,YAAImC,GAAcG,KAAK,GAC/BrC,EAAc,GAEXiB,EAAI,EAAGA,EAAIe,EAAaf,IAAK,CAClC,IAAMqB,EAAOC,KAAKC,MAAMD,KAAKE,SAAWP,EAAad,QAC/CsB,EAAWR,EAAaS,OAAOL,EAAM,GAAGM,MAE9C5C,EAAY6C,KAAKH,GACjB3C,EAAM2C,GAAY,EAGtB,MAAO,CACH3C,QAAOC,eGMD8C,CAAkBhD,EAAWkC,KACnC,CAAC5D,IAFG2B,EAPoB,EAOpBA,MAAOC,EAPa,EAObA,YAef,OAVAuB,qBACI,kBAAMF,WAAWpB,EAAU,IAAK,CAAExB,KLlBhB,iBKmBlB,CAACL,IASD,kBAACuD,EAAD,KACI,kBAACC,EAAkBxD,EACf,kBAACyD,EAAD,KACI,uCAAa5D,GACb,4CACgB,kBAAC,IAAD,CAAQuD,QAASM,MAGrC,kBAAC,EAAD,iBACQ1D,EADR,CAEIA,YAAaA,EACb+B,QAAShC,EACTuD,IAAK3B,EACL9B,MAAOA,EACP8B,MAAOA,EACPC,YAAaA,EACbC,SAAUA,EACV/B,WAAYA,EACZgC,YAxBhB,SAAqB6C,GACjB9C,EAAS,CAAExB,KLxBO,eKyBlB4C,WAAWpB,EAAU,IAAK,CAAExB,KAAMsE,ELvBf,cALF,YK4BwD9E,MAAOA,EAAQ,a,6LCQjF+E,MAhCf,WAAiB,IAAD,EAqBhB,SAAkBC,GAAmB,IAAD,EACJ5C,mBAAS4C,GADL,mBAC3BC,EAD2B,KAChBC,EADgB,KAOlC,MAAO,CAACD,EAJR,SAAqBE,GACnBD,EAAuB,cAAdD,EAA4B,aAAe,eAxBrBG,CAAS,aAD5B,mBACPH,EADO,KACIpB,EADJ,KAGRwB,EAAcC,YAAH,IAEG7F,EAAa,WAClBA,EAAa,eAK5B,OACE,kBAAC,IAAD,CAAeK,MAAOyF,EAAON,IAC3B,kBAAC,IAAMO,SAAP,KACE,kBAACH,EAAD,MACA,kBAAC,EAAD,CAAMxB,YAAaA,OCXP4B,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,iB","file":"static/js/main.6933e8f5.chunk.js","sourcesContent":["\nimport { path } from 'ramda';\n\nexport function getFromTheme (themePath = '') {\n    return function getFromThemeprops (props = {}) {\n        return path(themePath.split('.'), props.theme);\n    }\n}\n\nexport function wait(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n\n// getFromTheme(path) — is helper for getting nested props in styled components:\n\n// You can also add some logs to this function, for example if returning value is undefined or path is incorrect.","import { merge } from 'ramda';\n\nimport levels from '../config/levels';\n\nexport const NEW_LEVEL = 'level/new';\nexport const HIDDEN_CELL_HIDE = 'hidden/hide';\nexport const HIDDEN_CELL_SHOW = 'hidden/show';\nexport const FIELD_HIDE = 'field/hide';\nexport const FIELD_SHOW = 'field/show';\nexport const RESET_LEVEL = 'level/reset';\n\nconst START_LEVEL = 0;\n\nexport const initialState = {\n    level: START_LEVEL,\n    showHidden: true,\n    showField: false,\n    levelConfig: levels[START_LEVEL],\n}\n\nexport function GameReducer(state, action) {\n    switch(action.type) {\n        case NEW_LEVEL:\n            return merge(state, { level: action.level, levelConfig: levels[action.level] });\n        case HIDDEN_CELL_SHOW:\n            return merge(state, { showHidden: true });\n        case HIDDEN_CELL_HIDE:\n            return merge(state, { showHidden: false });\n        case FIELD_HIDE:\n            return merge(state, { showField: false });\n        case FIELD_SHOW:\n            return merge(state, { showField: true });\n        case RESET_LEVEL:\n            return merge(initialState, { levelConfig: { ...levels[START_LEVEL] } });\n        default:\n            return state;\n    }\n}\n\n\n// Here we declare our reducer, initial state and actions, which we will use in our game. If you have experience with Redux it won’t be something new for you.","import React, { memo } from 'react';\nimport styled from 'styled-components';\n\nimport { getFromTheme } from '../../utils';\nimport { CORRECT_GUESSED_CELL, HIDDEN_CELL } from '../game.utils';\n\nconst CellView = styled.div`\n    width: ${({ size }) => size}px;\n    height: ${({ size }) => size}px;\n    background: ${getFromTheme('cell.bg')};\n    margin: ${({ space }) => space}px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n\nconst ActiveCellView = styled.div`\n    width: ${({ width }) => width}%;\n    height: 100%;\n    background: ${getFromTheme('cell.activeBg')};\n    transition: width .2s ease;\n`;\n\nconst FailedCellView = styled.div`\n    width: ${({ size }) => size}%;\n    height: ${({ size }) => size}%;\n    background: ${getFromTheme('cell.failedBg')};\n    transition: width .2s ease, height .2s ease;\n`;\n\nexport const Cell = memo(function Cell(props) {\n    const { id, value, forceShowHidden } = props;\n\n    const isActive = (forceShowHidden && value === HIDDEN_CELL) || value === CORRECT_GUESSED_CELL;\n    const isFailed = !value;\n        \n    return (\n        <CellView {...props}>\n            <ActiveCellView id={id} width={isActive ? 100 : 0} />\n            <FailedCellView id={id} size={isFailed ? 100 : 0}/>\n        </CellView>\n    );\n});\n\n\n// Cell component is responsible for displaying cell’s current state (simple, guessed, wrong guessed). \n// CellView is used as container for ActiveCell and FailedCell. Active cell is visible if it was guessed \n// or if now is `show hidden` mode. Failed cell is visible only if it was clicked and it wasn’t hidden so \n// then its value is 0.\n\n\n\n","export function generateGameField(cellCount, memoryCount) {\n    const cellsIndexes = [...Array(cellCount * cellCount)]\n        .map((_, i) => i);\n    const field = [...cellsIndexes].fill(1);\n    const hiddenCells = [];\n\n    for (let i = 0; i < memoryCount; i++) {\n        const rNum = Math.floor(Math.random() * cellsIndexes.length);\n        const toChange = cellsIndexes.splice(rNum, 1).pop();\n\n        hiddenCells.push(toChange);\n        field[toChange] = 2;\n    }\n\n    return {\n        field, hiddenCells,\n    };\n}\n\nexport const WRONG_GUESSED_CELL = 0;\nexport const CORRECT_GUESSED_CELL = 3;\nexport const CELL = 1;\nexport const HIDDEN_CELL = 2;\n\n\n\n\n\n// This hook is used to generate game field, which is represented as array of integers. For example game field 3x3 will look like:\n// [1, 1, 2, 1, 2, 1, 1, 1, 2]\n// Where 1 is representation of simple untouched cell and 2 is representation of untouched hidden cell, which user will have to memorize and guess, 3 will be for touched cells which were guessed and 0 for touched and incorrectly guessed cell.\n// cellsIndexes— is auxiliary array from which we will get random cell;\n// field — is actual game field;\n// hiddenCells — is array of hidden cell indexes;\n// Then in loop from line 7 we’re generating random indexes, deleting them from auxiliary array, pushing them to hiddenCells array and update game field value to 2.\n// So at the end, we have fieldarray which represents game field and array of cell indexes which user will have to memorize.\n","import React, { memo, useState, useEffect } from 'react';\nimport styled from 'styled-components';\n\n\nimport { HIDDEN_CELL_HIDE, HIDDEN_CELL_SHOW } from '../game.reducer';\nimport { Cell } from './Cell';\nimport { WRONG_GUESSED_CELL, CORRECT_GUESSED_CELL } from '../game.utils';\n\nconst FieldView = styled.div`\n    width: 100%;\n    height: 100%;\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: space-between;\n    margin: 20px 0;\n    opacity: ${({ animationState }) => animationState};\n    transform: scale(${({ animationState }) => animationState});\n    transition: opacity .2s ease, transform .3s ease;\n`;\n\nexport const Field = memo(function Field ({\n    fieldSize = 0,\n    cellCount = 0,\n    space = 0,\n    field = [],\n    hiddenCells = [],\n    level = 0,\n    showHidden = false,\n    dispatch,\n    updateLevel,\n    visible,\n}) {\n    const cellSize = fieldSize / cellCount - space;\n\n    const { gameField, onCellClick } = useGameField(field, hiddenCells, updateLevel);\n   \n    useEffect(\n        () => {\n            dispatch({ type: HIDDEN_CELL_SHOW })\n            setTimeout(() => dispatch({ type: HIDDEN_CELL_HIDE }), 1500);\n        },\n        [level]\n    );\n\n    return (\n        <FieldView\n            animationState={visible ? 1 : 0}\n            onClick={!showHidden ? onCellClick : null}>\n            {\n                gameField.map((cellValue, i) => (\n                    <Cell\n                        size={cellSize}\n                        space={space}\n                        key={i}\n                        id={i}\n                        value={cellValue}\n                        forceShowHidden={showHidden} />\n                ))\n            }\n        </FieldView>\n    );\n});\n\nfunction useGameField(field, hiddenCells, updateLevel) {\n    const [gameField, setField] = useState(field);\n    const [gameHiddenCells, setHidden] = useState(hiddenCells);\n\n    function onCellClick({ target }) {\n        const id = Number(target.id);\n\n        if (hiddenCells.includes(id)) {\n            const updatedField = gameField.map((e, i) => i === id ? CORRECT_GUESSED_CELL : e);\n            const updatedHidden = gameHiddenCells.filter(e => e !== id);\n\n            setField(updatedField);\n            setHidden(updatedHidden);\n\n            return !updatedHidden.length && setTimeout(updateLevel, 1000);\n        }\n\n        const updatedField = gameField.map((e, i) => i === id ? WRONG_GUESSED_CELL : e);\n        setField(updatedField);\n\n        return setTimeout(updateLevel, 1000, true);\n    }\n\n    return { gameField, onCellClick };\n}\n\n\n// This component is responding for displaying game field, cells, and user interactions with cells.\n// Line 34: cellSize is counted by dividing field size on cell count minus space between cells, so that all the cells fit the field size.\n// Line 36: create new state and cell click handler to track user actions and guessed cells.\n// onCellClick — handler extracts cell id from event (id is representation of cell’s index in field array). Then it checks if this id is \n    //from array with hidden cells, if so it updates field and hidden cells and if all cells were guessed updates the level. If user made a mistake it resets the level.\n// Line 38-44: on every level change dispatches action to show hidden cells and then action to hide them with 1500 ms delay.\n// Line 65–89: useGameField hook creates two states: 1 to display current game field with guessed cells and 2 to track guessed cells.\n\n","import styled from 'styled-components';\n\nexport const GameView = styled.div`\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin: 80px 0;\n`;\n\nexport const GameFieldView = styled.div`\n    width: ${({ fieldSize, cellCount, space }) => fieldSize + cellCount * space}px;\n    height: ${({ fieldSize, cellCount, space }) => fieldSize + cellCount * space}px;\n    margin: 20px 0;\n`;\n\nexport const SwitchView = styled.div`\n    display: flex;\n    width: 100%;\n    justify-content: space-between;\n`;\n\n\n","import React, { memo, useReducer, useMemo, useEffect } from 'react';\n\nimport { Field } from './components/GameField';\nimport { GameFieldView, GameView, SwitchView } from './components/Styled';\nimport {\n    GameReducer, initialState, NEW_LEVEL,\n    FIELD_HIDE, FIELD_SHOW, RESET_LEVEL,\n} from './game.reducer';\nimport { generateGameField } from './game.utils';\nimport Switch from 'rc-switch';\n\nimport 'rc-switch/assets/index.css';\n\nfunction Game ({ toggleTheme }) {\n    const [{ level, showHidden, showField, levelConfig }, dispatch] = useReducer(\n        GameReducer, initialState\n    );\n\n    const { cellCount, memoryCount } = levelConfig;\n\n    const { field, hiddenCells } = useMemo(\n        () => generateGameField(cellCount, memoryCount),\n        [levelConfig]\n    );\n\n    useEffect(\n        () => setTimeout(dispatch, 500, { type: FIELD_SHOW }),\n        [levelConfig],\n    );\n\n    function updateLevel(shouldReset) {\n        dispatch({ type: FIELD_HIDE });\n        setTimeout(dispatch, 500, { type: shouldReset ? RESET_LEVEL : NEW_LEVEL, level: level + 1 });\n    }\n\n    return (\n        <GameView>\n            <GameFieldView {...levelConfig}>\n                <SwitchView>\n                    <div>Level: {level}</div>\n                    <div>\n                        Theme mode: <Switch onClick={toggleTheme} />\n                    </div>\n                </SwitchView>\n                <Field\n                    {...levelConfig}\n                    levelConfig={levelConfig}\n                    visible={showField}\n                    key={field}\n                    level={level}\n                    field={field}\n                    hiddenCells={hiddenCells}\n                    dispatch={dispatch}\n                    showHidden={showHidden}\n                    updateLevel={updateLevel}\n                />\n            </GameFieldView>\n        </GameView>\n    );\n}\n\nexport default memo(Game);\n\n\n\n// Here we have Game core component. Let’s go through it and see what it’s doing.\n// Line 15–17: here we use useReducer hook instead of Redux. It accepts reducer, initial state and returns us current state and dispatch function.\n// Line 21–24: here we use useMemo hook to memoize current game field state, so if user will change theme and this component will be rerendered, it will use memoized field, but if level will change, it will create a new one.\n// Line 26–29: useEffect hook is alternative to componentDidMount and componentDidUpdate. This hook will be triggered every time level change, to display game field if it’s hidden.\n// Line 31–34: we’re declaring function to update current level. Firstly it triggers FIELD_HIDE event and then NEW_LEVEL event with 500ms delay.\n// Line 62: we’re using memo helper to make our functional component like classPureComponent.\n// The rest of code shouldn’t be confusing.","import React, { useState } from 'react';\nimport { ThemeProvider, createGlobalStyle } from 'styled-components';\nimport { getFromTheme } from './utils';\nimport './index.css';\n\nimport Game from './game';\nimport themes from './config/themes.json';\n\nfunction App () {\n  const [themeName, toggleTheme] = useTheme('darkTheme');\n\n  const GlobalStyle = createGlobalStyle`\n    body {\n        background: ${getFromTheme('body.bg')};\n        color: ${getFromTheme('body.color')};\n        transition: background .3s ease;\n    }\n  `;\n  \n  return (\n    <ThemeProvider theme={themes[themeName]}>\n      <React.Fragment>\n        <GlobalStyle />\n        <Game toggleTheme={toggleTheme} />\n      </React.Fragment>\n    </ThemeProvider>\n  );\n}\n\nfunction useTheme(defaultThemeName) {\n  const [themeName, setTheme] = useState(defaultThemeName);\n\n  function switchTheme(name) {\n    setTheme(themeName === 'darkTheme' ? 'lightTheme' : 'darkTheme');\n  }\n\n  return [themeName, switchTheme];\n}\n\n\nexport default App;\n\n\n\n// Line 2 and 21: We’re importing ThemeProvider and passing it to current theme object, so every component which was created using styled components will have access to current theme.\n// Line 30–38: We write our first hook which uses inside React’s hook useState. More about React hooks here.\n// Line 10: We’re declaring our state for functional component which will store current theme name.\n// Line 12: We’re creating new global styles based on current theme, which will update on theme switch .\n// Line 30: We’re declaring help function to switch current theme, using setTheme. It’s like setState alternative for functional components.\n// Line 24: We’re passing theme switch callback to our app.\n// In my example I’m using only 2 themes. You can rewrite useTheme hook for a larger number of themes.\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n\n\n"],"sourceRoot":""}